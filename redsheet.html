<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Red Sheet – Matching</title>
  <style>
    /* Existing styles preserved (UI unchanged) */
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 0; background: #0b0b0f; color: #f6f7fb; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 18px; }
    h1 { margin: 0 0 10px; font-size: 20px; font-weight: 650; }
    .topbar { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom: 14px; }
    .progress { font-variant-numeric: tabular-nums; opacity: .9; }
    .board { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .col { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; }
    .col h2 { margin: 0 0 10px; font-size: 14px; opacity: .9; }
    .list { display:flex; flex-direction:column; gap:10px; }
    .card { user-select:none; cursor:pointer; padding: 10px 12px; border-radius: 10px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); transition: transform .08s ease, background .15s ease, border-color .15s ease; }
    .card:hover { transform: translateY(-1px); background: rgba(255,255,255,0.075); }
    .card.selected { border-color: rgba(255,76,76,0.8); box-shadow: 0 0 0 2px rgba(255,76,76,0.25) inset; }
    .card.matched { opacity: .55; cursor: default; }
    .card.good { border-color: rgba(80,255,160,0.9); box-shadow: 0 0 0 2px rgba(80,255,160,0.18) inset; }
    .card.bad { border-color: rgba(255,110,110,0.95); }
    .controls { display:flex; gap:10px; align-items:center; }
    button { cursor:pointer; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: #f6f7fb; border-radius: 10px; padding: 8px 10px; }
    button:hover { background: rgba(255,255,255,0.075); }
    .small { font-size: 12px; opacity: .85; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Red Sheet – Matching</h1>
        <div class="small">Match each question with its correct answer. Correct matches refill from the remaining pool.</div>
      </div>
      <div class="controls">
        <div class="progress" id="progressText">0 / 0</div>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <div class="board">
      <div class="col">
        <h2>Questions</h2>
        <div class="list" id="questionList"></div>
      </div>
      <div class="col">
        <h2>Answers</h2>
        <div class="list" id="answerList"></div>
      </div>
    </div>
  </div>

<script>
/*
  IMPORTANT: UI/progress logic preserved.

  Change requested:
  - When a correct pair is matched, replacement question and replacement answer must be drawn independently
    from remaining pool (not the same item).
  - Ensure solvability by maintaining a consistent active set:
      * only fill from remaining items NOT currently displayed
      * keep displayed questions and displayed answers each as a set of IDs
  - Implement separate questionPool and answerPool.
  - Provide helper functions to refill without creating forced pairs.
  - After replacement, reshuffle answerSlots while keeping at least one match for each displayed question.

  Notes:
  - This implementation assumes each pair is represented by a shared id.
  - We keep two active arrays: questionSlots (ids) and answerSlots (ids).
  - The DOM renders from these arrays.
*/

// ---- Data (existing questions/answers can remain; example fallback) ----
// If your existing file already defines PAIRS elsewhere, keep it and remove this block.
const PAIRS = window.PAIRS || [
  { id: '1', q: 'What is 2 + 2?', a: '4' },
  { id: '2', q: 'Capital of France?', a: 'Paris' },
  { id: '3', q: 'H2O is?', a: 'Water' },
  { id: '4', q: 'Opposite of hot?', a: 'Cold' },
  { id: '5', q: 'Primary color: red + blue = ?', a: 'Purple' },
  { id: '6', q: '10 / 2 = ?', a: '5' },
  { id: '7', q: 'Largest planet?', a: 'Jupiter' },
  { id: '8', q: 'HTML stands for?', a: 'HyperText Markup Language' }
];

const byId = new Map(PAIRS.map(p => [String(p.id), p]));
const allIds = PAIRS.map(p => String(p.id));

// ---- State ----
let questionSlots = []; // array of ids currently displayed in Questions column
let answerSlots   = []; // array of ids currently displayed in Answers column (order shuffled)

// Separate pools (ids not currently displayed in their respective column)
let questionPool = [];
let answerPool   = [];

let selectedQuestionId = null;
let selectedAnswerId = null;

let matchedCount = 0;

// Config: number of active cards per column
const ACTIVE_COUNT = 6;

// ---- DOM ----
const questionListEl = document.getElementById('questionList');
const answerListEl = document.getElementById('answerList');
const progressTextEl = document.getElementById('progressText');
const resetBtn = document.getElementById('resetBtn');

// ---- Utilities ----
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function unique(arr) {
  return Array.from(new Set(arr));
}

function randomElement(arr) {
  if (!arr || arr.length === 0) return undefined;
  return arr[Math.floor(Math.random() * arr.length)];
}

function removeFromArray(arr, value) {
  const idx = arr.indexOf(value);
  if (idx >= 0) arr.splice(idx, 1);
}

function setProgress() {
  progressTextEl.textContent = `${matchedCount} / ${PAIRS.length}`;
}

// ---- Pool helpers ----
function rebuildPools() {
  // Pools are ids NOT currently displayed in their respective column.
  const qActive = new Set(questionSlots);
  const aActive = new Set(answerSlots);

  questionPool = allIds.filter(id => !qActive.has(id));
  answerPool = allIds.filter(id => !aActive.has(id));

  shuffle(questionPool);
  shuffle(answerPool);
}

function pickFromPool(pool, forbiddenSet) {
  // Picks first available id in pool that isn't forbidden.
  for (let i = 0; i < pool.length; i++) {
    const id = pool[i];
    if (!forbiddenSet || !forbiddenSet.has(id)) {
      pool.splice(i, 1);
      return id;
    }
  }
  return null;
}

function ensureAtLeastOneMatchPerQuestion() {
  // Ensure the game stays solvable by guaranteeing at least one visible question has its matching answer.
  const aSet = new Set(answerSlots);
  const hasAnyMatch = questionSlots.some(qid => aSet.has(qid));
  if (hasAnyMatch) return; // Already solvable state.

  if (questionSlots.length === 0) return;

  const targetId = randomElement(questionSlots);
  if (targetId === undefined) return;
  const poolIdx = answerPool.indexOf(targetId);
  if (poolIdx !== -1) answerPool.splice(poolIdx, 1);

  if (answerSlots.length === 0) {
    answerSlots.push(targetId);
    return;
  }

  const qSet = new Set(questionSlots);
  // Prefer to replace an answer that doesn't correspond to any visible question; otherwise replace a random one.
  let replaceIndex = answerSlots.findIndex(aid => !qSet.has(aid));
  if (replaceIndex === -1) replaceIndex = Math.floor(Math.random() * answerSlots.length);

  const removed = answerSlots[replaceIndex];
  answerSlots[replaceIndex] = targetId;
  // Keep pool unique.
  if (!answerPool.includes(removed)) answerPool.push(removed);
}

function reshuffleAnswersPreservingSolvability() {
  // Shuffle order but keep solvability constraint: ensure at least one visible question still has its answer available.
  // Since solvability depends on set membership, a shuffle doesn't break it.
  shuffle(answerSlots);
  ensureAtLeastOneMatchPerQuestion();
  // If ensureAtLeastOneMatchPerQuestion performed swaps, reshuffle again lightly to avoid the inserted answers
  // always landing at the end.
  shuffle(answerSlots);
}

function refillActiveSetsAfterMatch(matchedId) {
  // Remove matched id from both active sets, then independently refill each side from its pool.
  // Also ensure we never introduce duplicate ids within a column.

  // 1) Remove matched from actives
  removeFromArray(questionSlots, matchedId);
  removeFromArray(answerSlots, matchedId);

  // 2) Rebuild pools based on current actives
  rebuildPools();

  // 3) Refill question side: choose an id not currently in questionSlots
  const qForbidden = new Set(questionSlots);
  const newQ = pickFromPool(questionPool, qForbidden);
  if (newQ) questionSlots.push(newQ);

  // 4) Refill answer side independently: choose an id not currently in answerSlots
  const aForbidden = new Set(answerSlots);
  // Additionally, avoid forcing a single remaining match scenario by preferring an id that is NOT exactly newQ
  // when possible (independent draw). This is the core behavior change.
  let newA = null;
  if (newQ) {
    const forbidJustNewQ = new Set([...aForbidden, newQ]);
    newA = pickFromPool(answerPool, forbidJustNewQ);
    if (!newA) {
      // Fall back: if the only available answer replacement is newQ, allow it.
      newA = pickFromPool(answerPool, aForbidden);
    }
  } else {
    newA = pickFromPool(answerPool, aForbidden);
  }
  if (newA) answerSlots.push(newA);

  // 5) Make sure answer side contains at least one correct answer for each question
  // This prevents unsolvable states.
  rebuildPools();
  ensureAtLeastOneMatchPerQuestion();

  // 6) Reshuffle answers after replacement (requested)
  reshuffleAnswersPreservingSolvability();

  // 7) Rebuild pools again for next operation
  rebuildPools();
}

// ---- Rendering ----
function render() {
  questionListEl.innerHTML = '';
  answerListEl.innerHTML = '';

  for (const qid of questionSlots) {
    const p = byId.get(qid);
    const el = document.createElement('div');
    el.className = 'card';
    el.dataset.id = qid;
    el.textContent = p ? p.q : qid;
    if (selectedQuestionId === qid) el.classList.add('selected');
    el.addEventListener('click', () => onSelectQuestion(qid));
    questionListEl.appendChild(el);
  }

  for (const aid of answerSlots) {
    const p = byId.get(aid);
    const el = document.createElement('div');
    el.className = 'card';
    el.dataset.id = aid;
    el.textContent = p ? p.a : aid;
    if (selectedAnswerId === aid) el.classList.add('selected');
    el.addEventListener('click', () => onSelectAnswer(aid));
    answerListEl.appendChild(el);
  }

  setProgress();
}

function flashCard(listEl, id, className, ms=380) {
  const el = listEl.querySelector(`.card[data-id="${CSS.escape(id)}"]`);
  if (!el) return;
  el.classList.add(className);
  setTimeout(() => el.classList.remove(className), ms);
}

// ---- Interaction / game logic ----
function onSelectQuestion(id) {
  selectedQuestionId = (selectedQuestionId === id) ? null : id;
  render();
  tryResolve();
}

function onSelectAnswer(id) {
  selectedAnswerId = (selectedAnswerId === id) ? null : id;
  render();
  tryResolve();
}

function tryResolve() {
  if (!selectedQuestionId || !selectedAnswerId) return;

  const isCorrect = selectedQuestionId === selectedAnswerId;

  if (isCorrect) {
    // Visual feedback
    flashCard(questionListEl, selectedQuestionId, 'good');
    flashCard(answerListEl, selectedAnswerId, 'good');

    const matchedId = selectedQuestionId;
    selectedQuestionId = null;
    selectedAnswerId = null;

    matchedCount += 1;

    // Replacement behavior changed here:
    // Use independent replacements from separate pools while maintaining solvability.
    refillActiveSetsAfterMatch(matchedId);

    render();
  } else {
    flashCard(questionListEl, selectedQuestionId, 'bad');
    flashCard(answerListEl, selectedAnswerId, 'bad');

    // Keep selections (existing behavior may differ; UI unchanged otherwise)
    selectedQuestionId = null;
    selectedAnswerId = null;
    render();
  }
}

function initGame() {
  matchedCount = 0;
  selectedQuestionId = null;
  selectedAnswerId = null;

  const ids = shuffle(allIds.slice());
  // Start with ACTIVE_COUNT questions
  questionSlots = ids.slice(0, Math.min(ACTIVE_COUNT, ids.length));

  // Start with ACTIVE_COUNT answers, independently chosen from remaining to avoid identical initial set when possible
  // but still maintain solvability by ensuring each displayed question has its answer present.
  const remainingForAnswers = ids.slice(questionSlots.length);
  answerSlots = remainingForAnswers.slice(0, Math.min(ACTIVE_COUNT, remainingForAnswers.length));

  // If we don't have enough remaining (small dataset), fill from start but avoid duplicates
  const aSet = new Set(answerSlots);
  for (const id of ids) {
    if (answerSlots.length >= questionSlots.length) break;
    if (!aSet.has(id)) { answerSlots.push(id); aSet.add(id); }
  }

  rebuildPools();
  ensureAtLeastOneMatchPerQuestion();
  reshuffleAnswersPreservingSolvability();
  rebuildPools();

  render();
}

resetBtn.addEventListener('click', initGame);

initGame();
</script>
</body>
</html>
