document.addEventListener('DOMContentLoaded', () => {
    // --- 要素取得 ---
    const fileManagerOverlay = document.getElementById('file-manager-overlay'); const fileList = document.getElementById('file-list'); const createNewFileBtn = document.getElementById('create-new-file-btn'); const mainApp = document.getElementById('main-app'); const backToFilesBtn = document.getElementById('back-to-files-btn'); const board = document.getElementById('board'); let svgLayer = document.getElementById('connector-svg-layer'); const addNoteBtn = document.getElementById('add-note-btn'); const addSectionBtn = document.getElementById('add-section-btn'); const addTextBtn = document.getElementById('add-text-btn'); const addShapeSquareBtn = document.getElementById('add-shape-square-btn'); const addShapeCircleBtn = document.getElementById('add-shape-circle-btn'); const addConnectorBtn = document.getElementById('add-connector-btn'); const exportBtn = document.getElementById('export-btn'); const importBtn = document.getElementById('import-btn'); const importFileInput = document.getElementById('import-file-input'); const cleanupBtn = document.getElementById('cleanup-btn'); const zoomDisplay = document.getElementById('zoom-display'); const zoomResetBtn = document.getElementById('zoom-reset-btn'); const undoBtn = document.getElementById('undo-btn'); const redoBtn = document.getElementById('redo-btn');
    
    // --- グローバル変数 ---
    let currentFileId = null; let notes = [], sections = [], textBoxes = [], shapes = [], connectors = []; let selectedElement = null; let boardState = {}; let isConnectorMode = false, connectorStartId = null; let historyStack = [], redoStack = []; const HISTORY_LIMIT = 50;
    const noteColors = ['#ffc', '#cfc', '#ccf', '#fcc', '#cff', '#fff']; const sectionColors = ['rgba(255, 0, 0, 0.1)', 'rgba(0, 0, 255, 0.1)', 'rgba(0, 128, 0, 0.1)', 'rgba(128, 0, 128, 0.1)', 'rgba(255, 165, 0, 0.1)', 'rgba(220, 220, 220, 0.5)']; const shapeColors = ['#ffffff', '#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff', '#bdb2ff', '#ffc6ff'];

    // --- 選択管理 ---
    function selectElement(element) { clearSelection(); selectedElement = element; if(element?.id) { document.getElementById(element.id)?.classList.add('selected'); } }
    function clearSelection() { if (selectedElement) { if(selectedElement.id){ document.getElementById(selectedElement.id)?.classList.remove('selected'); } } selectedElement = null; document.querySelectorAll('.connector-line.selected').forEach(l => l.classList.remove('selected')); }

    // --- ファイル管理 ---
    function getFileMetadata() { return JSON.parse(localStorage.getItem('board_files_metadata')) || []; }
    function saveFileMetadata(metadata) { localStorage.setItem('board_files_metadata', JSON.stringify(metadata)); }
    function showFileManager() { currentFileId = null; fileManagerOverlay.classList.remove('hidden'); mainApp.classList.add('hidden'); const metadata = getFileMetadata(); metadata.sort((a, b) => b.lastModified - a.lastModified); fileList.innerHTML = ''; if (metadata.length === 0) { fileList.innerHTML = '<li>ファイルがありません。新しいファイルを作成してください。</li>'; } metadata.forEach(file => { const li = document.createElement('li'); const lastModified = new Date(file.lastModified).toLocaleString(); li.innerHTML = `<span class="file-name">${file.name}</span><span class="file-meta">最終更新: ${lastModified}</span><div class="file-actions"><button class="rename-btn" title="名前を変更"><i class="fas fa-pen"></i></button><button class="delete-btn" title="削除"><i class="fas fa-trash"></i></button></div>`; fileList.appendChild(li); li.querySelector('.file-name').addEventListener('click', () => openFile(file.id)); li.querySelector('.rename-btn').addEventListener('click', () => renameFile(file.id, file.name)); li.querySelector('.delete-btn').addEventListener('click', () => deleteFile(file.id, file.name)); }); }
    function createNewFile() { const name = prompt('新しいファイルの名前を入力してください:', '無題のボード'); if (!name) return; const metadata = getFileMetadata(); const newFile = { id: `board_${Date.now()}`, name: name, lastModified: Date.now() }; metadata.push(newFile); saveFileMetadata(metadata); const emptyBoardData = { notes: [], sections: [], textBoxes: [], shapes: [], connectors: [], board: { panX: 0, panY: 0, scale: 1.0, noteZIndexCounter: 1000, sectionZIndexCounter: 1 } }; localStorage.setItem(newFile.id, JSON.stringify(emptyBoardData)); openFile(newFile.id); }
    function openFile(fileId) { currentFileId = fileId; fileManagerOverlay.classList.add('hidden'); mainApp.classList.remove('hidden'); loadState(); }
    function renameFile(fileId, oldName) { const newName = prompt('新しいファイル名を入力してください:', oldName); if (!newName || newName === oldName) return; let metadata = getFileMetadata(); const fileIndex = metadata.findIndex(f => f.id === fileId); if (fileIndex > -1) { metadata[fileIndex].name = newName; metadata[fileIndex].lastModified = Date.now(); saveFileMetadata(metadata); showFileManager(); } }
    function deleteFile(fileId, fileName) { if (!confirm(`「${fileName}」を完全に削除します。よろしいですか？`)) return; let metadata = getFileMetadata(); metadata = metadata.filter(f => f.id !== fileId); saveFileMetadata(metadata); localStorage.removeItem(fileId); showFileManager(); }
    
    // --- Undo/Redo 機能 ---
    function recordHistory() { const currentState = getCurrentState(); historyStack.push(currentState); if (historyStack.length > HISTORY_LIMIT) { historyStack.shift(); } redoStack = []; updateUndoRedoButtons(); }
    function undo() { if (historyStack.length === 0) return; redoStack.push(getCurrentState()); const prevState = historyStack.pop(); loadStateFromObject(prevState); saveState(); updateUndoRedoButtons(); }
    function redo() { if (redoStack.length === 0) return; historyStack.push(getCurrentState()); const nextState = redoStack.pop(); loadStateFromObject(nextState); saveState(); updateUndoRedoButtons(); }
    function updateUndoRedoButtons() { undoBtn.disabled = historyStack.length === 0; redoBtn.disabled = redoStack.length === 0; }
    function getCurrentState() { return { notes: notes.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, content: el.querySelector('.note-content').value, color: el.dataset.color, isLocked: el.classList.contains('locked') })), sections: sections.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, title: el.querySelector('.section-title').textContent, color: el.style.backgroundColor, isLocked: el.classList.contains('locked') })), textBoxes: textBoxes.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, zIndex: el.style.zIndex, content: el.querySelector('.text-content').innerHTML, width: el.style.width, isLocked: el.classList.contains('locked') })), shapes: shapes.map(el => ({ id: el.id, type: el.dataset.shapeType, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, label: el.querySelector('.shape-label').innerHTML, color: el.style.backgroundColor, isLocked: el.classList.contains('locked') })), connectors: connectors.map(c => ({ id: c.id, startId: c.startId, endId: c.endId })), board: boardState }; }
    function loadStateFromObject(state) { boardState = { panX: 0, panY: 0, scale: 1.0, noteZIndexCounter: 1000, sectionZIndexCounter: 1, ...state.board }; board.innerHTML = `<svg id="connector-svg-layer"></svg>`; svgLayer = document.getElementById('connector-svg-layer'); svgLayer.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#333" /></marker></defs>`; notes = []; sections = []; textBoxes = []; shapes = []; connectors = []; clearSelection(); if (state.sections) state.sections.forEach(data => createSection(data)); if (state.notes) state.notes.forEach(data => createNote(data)); if (state.textBoxes) state.textBoxes.forEach(data => createTextBox(data)); if (state.shapes) state.shapes.forEach(data => createShape(data)); if (state.connectors) { connectors = state.connectors; } applyTransform(); }
    function commitChange() { recordHistory(); saveState(); }

    // --- データ永続化 ---
    function saveState() { if (!currentFileId) return; let metadata = getFileMetadata(); const fileIndex = metadata.findIndex(f => f.id === currentFileId); if (fileIndex > -1) { metadata[fileIndex].lastModified = Date.now(); saveFileMetadata(metadata); } localStorage.setItem(currentFileId, JSON.stringify(getCurrentState())); }
    function loadState() { if (!currentFileId) return; const stateJSON = localStorage.getItem(currentFileId); if (!stateJSON) { showFileManager(); return; } const state = JSON.parse(stateJSON); loadStateFromObject(state); historyStack = [state]; redoStack = []; updateUndoRedoButtons(); }

    // --- ボード操作 ---
    function getElementCenter(elementId) { const el = document.getElementById(elementId); if (!el) return null; const x = parseFloat(el.style.left) + el.offsetWidth / 2; const y = parseFloat(el.style.top) + el.offsetHeight / 2; return { x, y }; }
    function drawAllConnectors() { if(!svgLayer) return; svgLayer.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#333" /></marker></defs>`; connectors.forEach(conn => { const startPoint = getElementCenter(conn.startId); const endPoint = getElementCenter(conn.endId); if (startPoint && endPoint) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', startPoint.x); line.setAttribute('y1', startPoint.y); line.setAttribute('x2', endPoint.x); line.setAttribute('y2', endPoint.y); line.setAttribute('class', 'connector-line'); line.dataset.id = conn.id; svgLayer.appendChild(line); line.addEventListener('mousedown', e => { e.stopPropagation(); clearSelection(); selectedElement = { type: 'connector', id: conn.id }; document.querySelectorAll('.connector-line').forEach(l=>l.classList.remove('selected')); line.classList.add('selected'); }); } }); }
    function applyTransform() { board.style.transform = `translate(${boardState.panX}px, ${boardState.panY}px) scale(${boardState.scale})`; updateZoomDisplay(); drawAllConnectors(); }
    function updateZoomDisplay() { zoomDisplay.textContent = `${Math.round(boardState.scale * 100)}%`; }
    function parseMarkdown(text) { let html = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/-(.*?)-/g, '<del>$1</del>'); html = html.split('\n').map(line => line.startsWith('* ') ? `<li>${line.substring(2)}</li>` : line).join('\n'); html = html.replace(/<li>(.*?)<\/li>/g, '<ul><li>$1</li></ul>').replace(/<\/ul>\n<ul>/g, ''); return html.replace(/\n/g, '<br>'); }
    
    function toggleConnectorMode(forceOff = false) { isConnectorMode = forceOff ? false : !isConnectorMode; connectorStartId = null; if (isConnectorMode) { addConnectorBtn.classList.add('active'); document.body.classList.add('connector-mode'); clearSelection(); } else { addConnectorBtn.classList.remove('active'); document.body.classList.remove('connector-mode'); } }
    function handleConnectorClick(elementId) { if (!connectorStartId) { connectorStartId = elementId; selectElement(document.getElementById(elementId)); } else { if (connectorStartId !== elementId) { recordHistory(); const newConnector = { id: `conn-${Date.now()}`, startId: connectorStartId, endId: elementId }; connectors.push(newConnector); drawAllConnectors(); saveState(); } toggleConnectorMode(true); } }

    // --- 要素作成関数群 ---
    function createNote(data = {}) { const note = document.createElement('div'); note.classList.add('note'); note.id = data.id || `note-${Date.now()}`; if (!data.id) { note.style.left = `${((window.innerWidth/2)-110-boardState.panX)/boardState.scale}px`; note.style.top = `${((window.innerHeight/2)-110-boardState.panY)/boardState.scale}px`; } else { note.style.left = data.x; note.style.top = data.y; } note.style.width = data.width || '220px'; note.style.height = data.height || '220px'; note.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; const noteColor = data.color || noteColors[Math.floor(Math.random()*noteColors.length)]; note.dataset.color = noteColor; const rawContent = data.content || ''; note.innerHTML = `<div class="note-header"><div class="color-picker">${noteColors.map(c => `<div class="color-dot" style="background-color: ${c};" data-color="${c}"></div>`).join('')}</div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div></div><div class="note-body"><div class="note-view">${parseMarkdown(rawContent)}</div><textarea class="note-content" style="display: none;">${rawContent}</textarea></div><div class="resizer"></div>`; updateNoteColor(note, noteColor); board.insertBefore(note, svgLayer); notes.push(note); if (!data.id) commitChange(); if (data.isLocked) { note.classList.add('locked'); note.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    note.addEventListener('mousedown', (e) => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(note.id); return; } selectElement(note); if(!note.classList.contains('locked')) { recordHistory(); note.style.zIndex = boardState.noteZIndexCounter++; saveState(); } });
    const header = note.querySelector('.note-header'); header.addEventListener('mousedown', e => { if (note.classList.contains('locked') || isConnectorMode) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); note.style.zIndex = boardState.noteZIndexCounter++; const onMouseMove = ev => { note.style.left = `${parseFloat(note.style.left) + ev.movementX / boardState.scale}px`; note.style.top = `${parseFloat(note.style.top) + ev.movementY / boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const resizer = note.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (note.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW = note.offsetWidth, startH = note.offsetHeight, startX = e.clientX, startY = e.clientY; const onMouseMove = ev => { note.style.width = `${startW + (ev.clientX - startX) / boardState.scale}px`; note.style.height = `${startH + (ev.clientY - startY) / boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const noteBody = note.querySelector('.note-body'); const view = note.querySelector('.note-view'); const content = note.querySelector('.note-content'); const deleteBtn = note.querySelector('.delete-btn'); const colorDots = note.querySelectorAll('.color-dot'); const lockBtn = note.querySelector('.lock-btn');
    noteBody.addEventListener('dblclick', (e) => { if (note.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); view.style.display = 'none'; content.style.display = 'block'; content.focus(); });
    content.addEventListener('blur', () => { if (note.classList.contains('locked')) return; view.innerHTML = parseMarkdown(content.value); view.style.display = 'block'; content.style.display = 'none'; commitChange(); });
    deleteBtn.addEventListener('click', (e) => { if (note.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === note) clearSelection(); recordHistory(); notes = notes.filter(n => n.id !== note.id); connectors = connectors.filter(c => c.startId !== note.id && c.endId !== note.id); drawAllConnectors(); note.remove(); saveState(); });
    colorDots.forEach(dot => { dot.addEventListener('click', e => { if (note.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); updateNoteColor(note, dot.dataset.color); saveState(); }); });
    lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = note.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); }); }
    function updateNoteColor(note, color) { note.dataset.color = color; note.querySelector('.note-header').style.backgroundColor = color; note.querySelector('.note-body').style.backgroundColor = color; }

    function createSection(data = {}) { const section = document.createElement('div'); section.classList.add('section'); section.id = data.id || `section-${Date.now()}`; if (!data.id) { section.style.left = `${((window.innerWidth/2)-200-boardState.panX)/boardState.scale}px`; section.style.top = `${((window.innerHeight/2)-200-boardState.panY)/boardState.scale}px`; } else { section.style.left = data.x; section.style.top = data.y; } section.style.width = data.width || '400px'; section.style.height = data.height || '400px'; section.style.zIndex = data.zIndex || boardState.sectionZIndexCounter++; section.style.backgroundColor = data.color || sectionColors[Math.floor(Math.random()*sectionColors.length)]; const title = data.title || '新しいセクション'; section.innerHTML = `<div class="section-header"><div class="section-title">${title}</div><div class="section-controls"><div class="color-picker">${sectionColors.map(c=>`<div class="color-dot" style="background-color: ${c};" data-color="${c}"></div>`).join('')}</div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div></div></div><div class="resizer"></div>`; board.insertBefore(section, svgLayer); sections.push(section); if (!data.id) commitChange(); if (data.isLocked) { section.classList.add('locked'); section.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    const startSectionDrag = (e) => { if (section.classList.contains('locked')) return; recordHistory(); document.body.classList.add('is-dragging'); section.style.zIndex = boardState.sectionZIndexCounter++; let attachedNotes = []; const sLeft=parseFloat(section.style.left), sTop=parseFloat(section.style.top), sRight=sLeft+section.offsetWidth, sBottom=sTop+section.offsetHeight; [...notes, ...shapes, ...textBoxes].forEach(el => { const nLeft=parseFloat(el.style.left), nTop=parseFloat(el.style.top); const nMidX=nLeft+el.offsetWidth/2, nMidY=nTop+el.offsetHeight/2; if (nMidX > sLeft && nMidX < sRight && nMidY > sTop && nMidY < sBottom) { attachedNotes.push(el); } }); const onMouseMove = ev => { const dx=ev.movementX/boardState.scale, dy=ev.movementY/boardState.scale; section.style.left=`${parseFloat(section.style.left)+dx}px`; section.style.top=`${parseFloat(section.style.top)+dy}px`; attachedNotes.forEach(el => { el.style.left=`${parseFloat(el.style.left)+dx}px`; el.style.top=`${parseFloat(el.style.top)+dy}px`; }); drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); };
    const header = section.querySelector('.section-header'); header.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(section.id); return; } selectElement(section); startSectionDrag(e); }); section.addEventListener('mousedown', e => { if (e.target === section) { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(section.id); return; } selectElement(section); startSectionDrag(e); }});
    const resizer = section.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW=section.offsetWidth, startH=section.offsetHeight, startX=e.clientX, startY=e.clientY; const onMouseMove = ev => { section.style.width=`${startW+(ev.clientX-startX)/boardState.scale}px`; section.style.height=`${startH+(ev.clientY-startY)/boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const titleEl = section.querySelector('.section-title'); titleEl.addEventListener('dblclick', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); const i=document.createElement('input'); i.type='text'; i.value=titleEl.textContent; i.className='section-title-input'; titleEl.replaceWith(i); i.focus(); i.select(); i.addEventListener('blur',()=>{titleEl.textContent=i.value||"無題";i.replaceWith(titleEl);commitChange();}); i.addEventListener('keydown',(ev)=>{if(ev.key==='Enter')i.blur();}); });
    const deleteBtn = section.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === section) clearSelection(); recordHistory(); sections = sections.filter(s => s.id !== section.id); connectors = connectors.filter(c => c.startId !== section.id && c.endId !== section.id); drawAllConnectors(); section.remove(); saveState(); });
    const colorDots = section.querySelectorAll('.color-dot'); colorDots.forEach(dot => { dot.addEventListener('click', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); section.style.backgroundColor = dot.dataset.color; saveState(); }); });
    const lockBtn = section.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = section.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); }); }

    function createTextBox(data = {}) { const textBox = document.createElement('div'); textBox.classList.add('text-box'); textBox.id = data.id || `text-${Date.now()}`; if (!data.id) { textBox.style.left = `${((window.innerWidth/2)-100-boardState.panX)/boardState.scale}px`; textBox.style.top = `${((window.innerHeight/2)-50-boardState.panY)/boardState.scale}px`; } else { textBox.style.left = data.x; textBox.style.top = data.y; } textBox.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; textBox.style.width = data.width || 'auto'; textBox.innerHTML = `<div class="text-content" contenteditable="false">${data.content || 'テキストを入力'}</div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div>`; board.insertBefore(textBox, svgLayer); textBoxes.push(textBox); if (!data.id) commitChange(); if (data.isLocked) { textBox.classList.add('locked'); textBox.querySelector('.lock-btn i').className = 'fas fa-lock'; textBox.querySelector('.text-content').contentEditable = 'false'; } else { textBox.querySelector('.text-content').contentEditable = 'true'; }
    const content = textBox.querySelector('.text-content'); textBox.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(textBox.id); return; } selectElement(textBox); if (textBox.classList.contains('locked')) return; if (e.target !== content) { document.body.classList.add('is-dragging'); recordHistory(); textBox.style.zIndex = boardState.noteZIndexCounter++; const onMouseMove = ev => { textBox.style.left = `${parseFloat(textBox.style.left)+ev.movementX/boardState.scale}px`; textBox.style.top = `${parseFloat(textBox.style.top)+ev.movementY/boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); } });
    content.addEventListener('input', () => { if (textBox.classList.contains('locked')) return; textBox.style.width = 'auto'; commitChange(); }); content.addEventListener('mousedown', e => e.stopPropagation());
    const deleteBtn = textBox.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (textBox.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === textBox) clearSelection(); recordHistory(); textBoxes = textBoxes.filter(t => t.id !== textBox.id); connectors = connectors.filter(c => c.startId !== textBox.id && c.endId !== textBox.id); drawAllConnectors(); textBox.remove(); saveState(); });
    const lockBtn = textBox.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = textBox.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; content.contentEditable = !isLocked; if(isLocked) clearSelection(); saveState(); }); }

    function createShape(data = {}) { const shape = document.createElement('div'); shape.classList.add('shape', data.type); shape.dataset.shapeType = data.type; shape.id = data.id || `shape-${Date.now()}`; if (!data.id) { shape.style.left = `${((window.innerWidth/2)-75-boardState.panX)/boardState.scale}px`; shape.style.top = `${((window.innerHeight/2)-75-boardState.panY)/boardState.scale}px`; } else { shape.style.left = data.x; shape.style.top = data.y; } shape.style.width = data.width || '150px'; shape.style.height = data.height || '150px'; shape.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; shape.style.backgroundColor = data.color || shapeColors[0]; shape.innerHTML = `<div class="shape-label" contenteditable="false">${data.label || ''}</div><div class="resizer"></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="color-picker">${shapeColors.map(c => `<div class="color-dot" style="background-color: ${c};" data-color="${c}"></div>`).join('')}</div>`; board.insertBefore(shape, svgLayer); shapes.push(shape); if (!data.id) commitChange(); if (data.isLocked) { shape.classList.add('locked'); shape.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    shape.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(shape.id); return; } selectElement(shape); if (shape.classList.contains('locked')) return; recordHistory(); shape.style.zIndex = boardState.noteZIndexCounter++; if (e.target !== shape.querySelector('.shape-label')) { document.body.classList.add('is-dragging'); const onMouseMove = ev => { shape.style.left = `${parseFloat(shape.style.left)+ev.movementX/boardState.scale}px`; shape.style.top = `${parseFloat(shape.style.top)+ev.movementY/boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); } });
    const resizer = shape.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW=shape.offsetWidth, startH=shape.offsetHeight, startX=e.clientX, startY=e.clientY; const aspectRatio = startW / startH; const onMouseMove = ev => { if (ev.shiftKey) { const deltaX = ev.clientX - startX; const newWidth = startW + deltaX / boardState.scale; shape.style.width=`${newWidth}px`; shape.style.height=`${newWidth / aspectRatio}px`; } else { shape.style.width=`${startW+(ev.clientX-startX)/boardState.scale}px`; shape.style.height=`${startH+(ev.clientY-startY)/boardState.scale}px`; } drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const label = shape.querySelector('.shape-label'); label.addEventListener('dblclick', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); label.contentEditable = 'true'; label.focus(); }); label.addEventListener('blur', () => { label.contentEditable = 'false'; commitChange(); }); label.addEventListener('mousedown', e => e.stopPropagation());
    const deleteBtn = shape.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === shape) clearSelection(); recordHistory(); shapes = shapes.filter(s => s.id !== shape.id); connectors = connectors.filter(c => c.startId !== shape.id && c.endId !== shape.id); drawAllConnectors(); shape.remove(); saveState(); });
    const colorDots = shape.querySelectorAll('.color-dot'); colorDots.forEach(dot => { dot.addEventListener('click', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); shape.style.backgroundColor = dot.dataset.color; saveState(); }); });
    const lockBtn = shape.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = shape.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); }); }
    
    window.addEventListener('keydown', e => { if (mainApp.classList.contains('hidden')) return; if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } if (e.ctrlKey && e.key.toLowerCase() === 'y' || (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z')) { e.preventDefault(); redo(); } if (!selectedElement) return; if (document.activeElement.isContentEditable || /TEXTAREA|INPUT/.test(document.activeElement.tagName)) return; if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); if (selectedElement.type === 'connector') { recordHistory(); connectors = connectors.filter(c => c.id !== selectedElement.id); drawAllConnectors(); saveState(); clearSelection(); return; } if (selectedElement.classList.contains('locked')) return; selectedElement.querySelector('.delete-btn')?.click(); } if (e.ctrlKey && e.key.toLowerCase() === 'd') { e.preventDefault(); if (selectedElement.classList.contains('locked') || selectedElement.type === 'connector') return; let originalData, createFn; const fileData = JSON.parse(localStorage.getItem(currentFileId)); if (selectedElement.classList.contains('note')) { originalData = fileData.notes.find(n => n.id === selectedElement.id); createFn = createNote; } else if (selectedElement.classList.contains('section')) { originalData = fileData.sections.find(s => s.id === selectedElement.id); createFn = createSection; } else if (selectedElement.classList.contains('text-box')) { originalData = fileData.textBoxes.find(t => t.id === selectedElement.id); createFn = createTextBox; } else if (selectedElement.classList.contains('shape')) { originalData = fileData.shapes.find(s => s.id === selectedElement.id); createFn = createShape; } if (createFn) { recordHistory(); const dataToClone = { ...originalData }; delete dataToClone.id; delete dataToClone.zIndex; dataToClone.x = `${parseFloat(dataToClone.x) + 20 / boardState.scale}px`; dataToClone.y = `${parseFloat(dataToClone.y) + 20 / boardState.scale}px`; createFn(dataToClone); } } });
    window.addEventListener('wheel', e => { e.preventDefault(); recordHistory(); if (e.shiftKey) { boardState.panX -= e.deltaY; } else { const z = 1.1, o = boardState.scale; let n=e.deltaY<0?o*z:o/z; n=Math.max(0.2,Math.min(n,3.0)); boardState.scale=n; boardState.panX=e.clientX-((e.clientX-boardState.panX)/o*n); boardState.panY=e.clientY-((e.clientY-boardState.panY)/o*n); } applyTransform(); saveState(); }, { passive: false });
    board.addEventListener('mousedown', e => { if (e.target !== board) return; clearSelection(); toggleConnectorMode(true); document.body.classList.add('is-dragging'); board.classList.add('grabbing'); recordHistory(); const onMouseMove = ev => { boardState.panX += ev.movementX; boardState.panY += ev.movementY; applyTransform(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); board.classList.remove('grabbing'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    zoomResetBtn.addEventListener('click', () => { recordHistory(); boardState.scale = 1.0; boardState.panX = -(board.offsetWidth-window.innerWidth)/2; boardState.panY=-(board.offsetHeight-window.innerHeight)/2; applyTransform(); saveState(); });
    addNoteBtn.addEventListener('click', () => { toggleConnectorMode(true); createNote(); }); addSectionBtn.addEventListener('click', () => { toggleConnectorMode(true); createSection(); }); addTextBtn.addEventListener('click', () => { toggleConnectorMode(true); createTextBox(); }); addShapeSquareBtn.addEventListener('click', () => { toggleConnectorMode(true); createShape({type: 'square'}); }); addShapeCircleBtn.addEventListener('click', () => { toggleConnectorMode(true); createShape({type: 'circle'}); }); addConnectorBtn.addEventListener('click', () => toggleConnectorMode());
    backToFilesBtn.addEventListener('click', showFileManager); createNewFileBtn.addEventListener('click', createNewFile);
    exportBtn.addEventListener('click', () => { saveState(); const d = localStorage.getItem(currentFileId); if (!d) { alert('エクスポートするデータがありません。'); return; } const b = new Blob([d],{type:'application/json'}); const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='board-export.json'; a.click(); URL.revokeObjectURL(a.href); });
    importBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', e => { const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=ev=>{try{ JSON.parse(ev.target.result); if(confirm('現在のボードをインポートした内容で上書きします。よろしいですか？')){ recordHistory(); localStorage.setItem(currentFileId, ev.target.result); loadState();}}catch(err){alert('無効なファイルです。')}}; r.readAsText(f); e.target.value='';});
    cleanupBtn.addEventListener('click', () => { if (confirm('すべてのファイルとデータを消去して完全にリセットします。この操作は元に戻せません。よろしいですか？')) { localStorage.clear(); location.reload(); } });
    undoBtn.addEventListener('click', undo); redoBtn.addEventListener('click', redo);

    showFileManager();
});