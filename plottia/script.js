document.addEventListener('DOMContentLoaded', () => {
    // --- 要素取得 ---
    const fileManagerOverlay = document.getElementById('file-manager-overlay'); const fileList = document.getElementById('file-list'); const createNewFileBtn = document.getElementById('create-new-file-btn'); const mainApp = document.getElementById('main-app'); const backToFilesBtn = document.getElementById('back-to-files-btn'); const board = document.getElementById('board'); let svgLayer = document.getElementById('connector-svg-layer'); const addNoteBtn = document.getElementById('add-note-btn'); const addSectionBtn = document.getElementById('add-section-btn'); const addTextBtn = document.getElementById('add-text-btn'); const addShapeSquareBtn = document.getElementById('add-shape-square-btn'); const addShapeCircleBtn = document.getElementById('add-shape-circle-btn'); const addShapeDiamondBtn = document.getElementById('add-shape-diamond-btn'); const addConnectorBtn = document.getElementById('add-connector-btn'); const penToolBtn = document.getElementById('pen-tool-btn'); const exportBtn = document.getElementById('export-btn'); const importBtn = document.getElementById('import-btn'); const importFileInput = document.getElementById('import-file-input'); const cleanupBtn = document.getElementById('cleanup-btn'); const zoomDisplay = document.getElementById('zoom-display'); const zoomResetBtn = document.getElementById('zoom-reset-btn'); const undoBtn = document.getElementById('undo-btn'); const redoBtn = document.getElementById('redo-btn'); const darkModeBtn = document.getElementById('dark-mode-btn'); const minimap = document.getElementById('minimap'); const guideContainer = document.getElementById('guide-container');
    
    // --- グローバル変数 ---
    let currentFileId = null; let notes = [], sections = [], textBoxes = [], shapes = [], connectors = [], drawings = []; let selectedElement = null; let boardState = {}; let isConnectorMode = false, connectorStartId = null; let isDrawingMode = false, currentDrawingPath = null, currentDrawingElement = null; let historyStack = [], redoStack = []; const HISTORY_LIMIT = 50;
    const noteColors = ['#ffc', '#cfc', '#ccf', '#fcc', '#cff', '#fff']; const sectionColors = ['rgba(255, 0, 0, 0.1)', 'rgba(0, 0, 255, 0.1)', 'rgba(0, 128, 0, 0.1)', 'rgba(128, 0, 128, 0.1)', 'rgba(255, 165, 0, 0.1)', 'rgba(220, 220, 220, 0.5)']; const shapeColors = ['#ffffff', '#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff', '#bdb2ff', '#ffc6ff'];

    function selectElement(element) { clearSelection(); selectedElement = element; if(element?.id) { document.getElementById(element.id)?.classList.add('selected'); } }
    function clearSelection() { if (selectedElement) { if(selectedElement.id){ document.getElementById(selectedElement.id)?.classList.remove('selected'); } } selectedElement = null; document.querySelectorAll('.connector-line.selected').forEach(l => l.classList.remove('selected')); }
    function getFileMetadata() { return JSON.parse(localStorage.getItem('plottia_files_metadata')) || []; }
    function saveFileMetadata(metadata) { localStorage.setItem('plottia_files_metadata', JSON.stringify(metadata)); }
    function showFileManager() { currentFileId = null; fileManagerOverlay.classList.remove('hidden'); mainApp.classList.add('hidden'); const metadata = getFileMetadata(); metadata.sort((a, b) => b.lastModified - a.lastModified); fileList.innerHTML = ''; if (metadata.length === 0) { fileList.innerHTML = '<li>ファイルがありません。新しいファイルを作成してください。</li>'; } metadata.forEach(file => { const li = document.createElement('li'); const lastModified = new Date(file.lastModified).toLocaleString(); li.innerHTML = `<span class="file-name">${file.name}</span><span class="file-meta">最終更新: ${lastModified}</span><div class="file-actions"><button class="rename-btn" title="名前を変更"><i class="fas fa-pen"></i></button><button class="delete-btn" title="削除"><i class="fas fa-trash"></i></button></div>`; fileList.appendChild(li); li.querySelector('.file-name').addEventListener('click', () => openFile(file.id)); li.querySelector('.rename-btn').addEventListener('click', () => renameFile(file.id, file.name)); li.querySelector('.delete-btn').addEventListener('click', () => deleteFile(file.id, file.name)); }); }
    function createNewFile() { const name = prompt('新しいファイルの名前を入力してください:', '無題のボード'); if (!name) return; const metadata = getFileMetadata(); const newFile = { id: `plottia_board_${Date.now()}`, name: name, lastModified: Date.now() }; metadata.push(newFile); saveFileMetadata(metadata); const emptyBoardData = { notes: [], sections: [], textBoxes: [], shapes: [], drawings: [], connectors: [], board: { panX: 0, panY: 0, scale: 1.0, noteZIndexCounter: 1000, sectionZIndexCounter: 1 } }; localStorage.setItem(newFile.id, JSON.stringify(emptyBoardData)); openFile(newFile.id); }
    function openFile(fileId) { currentFileId = fileId; fileManagerOverlay.classList.add('hidden'); mainApp.classList.remove('hidden'); loadState(); }
    function renameFile(fileId, oldName) { const newName = prompt('新しいファイル名を入力してください:', oldName); if (!newName || newName === oldName) return; let metadata = getFileMetadata(); const fileIndex = metadata.findIndex(f => f.id === fileId); if (fileIndex > -1) { metadata[fileIndex].name = newName; metadata[fileIndex].lastModified = Date.now(); saveFileMetadata(metadata); showFileManager(); } }
    function deleteFile(fileId, fileName) { if (!confirm(`「${fileName}」を完全に削除します。よろしいですか？`)) return; let metadata = getFileMetadata(); metadata = metadata.filter(f => f.id !== fileId); saveFileMetadata(metadata); localStorage.removeItem(fileId); showFileManager(); }
    
    function recordHistory() { const currentState = getCurrentState(); historyStack.push(currentState); if (historyStack.length > HISTORY_LIMIT) { historyStack.shift(); } redoStack = []; updateUndoRedoButtons(); }
    function undo() { if (historyStack.length === 0) return; redoStack.push(getCurrentState()); const prevState = historyStack.pop(); loadStateFromObject(prevState); saveState(); updateUndoRedoButtons(); }
    function redo() { if (redoStack.length === 0) return; historyStack.push(getCurrentState()); const nextState = redoStack.pop(); loadStateFromObject(nextState); saveState(); updateUndoRedoButtons(); }
    function updateUndoRedoButtons() { undoBtn.disabled = historyStack.length === 0; redoBtn.disabled = redoStack.length === 0; }
    function getCurrentState() { return { notes: notes.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, content: el.querySelector('.note-content').value, color: el.dataset.color, isLocked: el.classList.contains('locked') })), sections: sections.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, title: el.querySelector('.section-title').textContent, color: el.style.backgroundColor, isLocked: el.classList.contains('locked') })), textBoxes: textBoxes.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, zIndex: el.style.zIndex, content: el.querySelector('.text-content').innerHTML, width: el.style.width, isLocked: el.classList.contains('locked') })), shapes: shapes.map(el => ({ id: el.id, type: el.dataset.shapeType, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, label: el.querySelector('.shape-label').innerHTML, color: el.querySelector('.shape-visual').style.backgroundColor, isLocked: el.classList.contains('locked') })), drawings: drawings.map(el => ({ id: el.id, x: el.style.left, y: el.style.top, width: el.style.width, height: el.style.height, zIndex: el.style.zIndex, paths: el.paths, color: el.color, strokeWidth: el.strokeWidth, isLocked: el.classList.contains('locked') })), connectors: connectors.map(c => ({ id: c.id, startId: c.startId, endId: c.endId })), board: boardState }; }
    function loadStateFromObject(state) { boardState = { panX: 0, panY: 0, scale: 1.0, noteZIndexCounter: 1000, sectionZIndexCounter: 1, ...state.board }; board.innerHTML = `<div id="guide-container"></div><svg id="connector-svg-layer"></svg>`; svgLayer = document.getElementById('connector-svg-layer'); svgLayer.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#333" /></marker></defs>`; notes = []; sections = []; textBoxes = []; shapes = []; connectors = []; drawings = []; clearSelection(); if (state.sections) state.sections.forEach(data => createSection(data)); if (state.notes) state.notes.forEach(data => createNote(data)); if (state.textBoxes) state.textBoxes.forEach(data => createTextBox(data)); if (state.shapes) state.shapes.forEach(data => createShape(data)); if (state.drawings) state.drawings.forEach(data => createDrawing(data)); if (state.connectors) { connectors = state.connectors; } applyTransform(); }
    function commitChange() { recordHistory(); saveState(); }

    function saveState() { if (!currentFileId) return; let metadata = getFileMetadata(); const fileIndex = metadata.findIndex(f => f.id === currentFileId); if (fileIndex > -1) { metadata[fileIndex].lastModified = Date.now(); saveFileMetadata(metadata); } localStorage.setItem(currentFileId, JSON.stringify(getCurrentState())); }
    function loadState() { if (!currentFileId) return; const stateJSON = localStorage.getItem(currentFileId); if (!stateJSON) { showFileManager(); return; } const state = JSON.parse(stateJSON); loadStateFromObject(state); historyStack = [state]; redoStack = []; updateUndoRedoButtons(); }

    function getElementCenter(elementId) { const el = document.getElementById(elementId); if (!el) return null; const x = parseFloat(el.style.left) + el.offsetWidth / 2; const y = parseFloat(el.style.top) + el.offsetHeight / 2; return { x, y }; }
    function drawAllConnectors() { if(!svgLayer) return; svgLayer.innerHTML = `<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#333" /></marker></defs>`; connectors.forEach(conn => { const startPoint = getElementCenter(conn.startId); const endPoint = getElementCenter(conn.endId); if (startPoint && endPoint) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', startPoint.x); line.setAttribute('y1', startPoint.y); line.setAttribute('x2', endPoint.x); line.setAttribute('y2', endPoint.y); line.setAttribute('class', 'connector-line'); line.dataset.id = conn.id; svgLayer.appendChild(line); line.addEventListener('mousedown', e => { e.stopPropagation(); clearSelection(); selectedElement = { type: 'connector', id: conn.id }; document.querySelectorAll('.connector-line').forEach(l=>l.classList.remove('selected')); line.classList.add('selected'); }); } }); }
    function applyTransform() { board.style.transform = `translate(${boardState.panX}px, ${boardState.panY}px) scale(${boardState.scale})`; updateZoomDisplay(); drawAllConnectors(); updateMinimap(); }
    function updateZoomDisplay() { zoomDisplay.textContent = `${Math.round(boardState.scale * 100)}%`; }
    function parseMarkdown(text) { let html = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/-(.*?)-/g, '<del>$1</del>'); html = html.split('\n').map(line => line.startsWith('* ') ? `<li>${line.substring(2)}</li>` : line).join('\n'); html = html.replace(/<li>(.*?)<\/li>/g, '<ul><li>$1</li></ul>').replace(/<\/ul>\n<ul>/g, ''); return html.replace(/\n/g, '<br>'); }
    
    function toggleConnectorMode(forceOff = false) { isConnectorMode = forceOff ? false : !isConnectorMode; connectorStartId = null; if (isConnectorMode) { addConnectorBtn.classList.add('active'); document.body.classList.add('connector-mode'); toggleDrawingMode(true); clearSelection(); } else { addConnectorBtn.classList.remove('active'); document.body.classList.remove('connector-mode'); } }
    function handleConnectorClick(elementId) { if (!connectorStartId) { connectorStartId = elementId; selectElement(document.getElementById(elementId)); } else { if (connectorStartId !== elementId) { recordHistory(); const newConnector = { id: `conn-${Date.now()}`, startId: connectorStartId, endId: elementId }; connectors.push(newConnector); drawAllConnectors(); saveState(); } toggleConnectorMode(true); } }
    
    function toggleDrawingMode(forceOff = false) { isDrawingMode = forceOff ? false : !isDrawingMode; if (isDrawingMode) { penToolBtn.classList.add('active'); document.body.classList.add('drawing-mode'); toggleConnectorMode(true); clearSelection(); } else { penToolBtn.classList.remove('active'); document.body.classList.remove('drawing-mode'); } }

    function createNote(data = {}) { const note = document.createElement('div'); note.classList.add('note'); note.id = data.id || `note-${Date.now()}`; if (!data.id) { note.style.left = `${((window.innerWidth/2)-110-boardState.panX)/boardState.scale}px`; note.style.top = `${((window.innerHeight/2)-110-boardState.panY)/boardState.scale}px`; } else { note.style.left = data.x; note.style.top = data.y; } note.style.width = data.width || '220px'; note.style.height = data.height || '220px'; note.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; const noteColor = data.color || noteColors[Math.floor(Math.random()*noteColors.length)]; note.dataset.color = noteColor; const rawContent = data.content || ''; note.innerHTML = `<div class="note-header"><div class="color-picker">${noteColors.map(c => `<div class="color-dot" style="background-color: ${c};" data-color="${c}"></div>`).join('')}</div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div></div><div class="note-body"><div class="note-view">${parseMarkdown(rawContent)}</div><textarea class="note-content" style="display: none;">${rawContent}</textarea></div><div class="resizer"></div>`; updateNoteColor(note, noteColor); board.insertBefore(note, svgLayer); notes.push(note); if (!data.id) commitChange(); if (data.isLocked) { note.classList.add('locked'); note.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    note.addEventListener('mousedown', (e) => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(note.id); return; } selectElement(note); if(!note.classList.contains('locked')) { recordHistory(); note.style.zIndex = boardState.noteZIndexCounter++; saveState(); } });
    const header = note.querySelector('.note-header'); header.addEventListener('mousedown', e => { if (note.classList.contains('locked') || isConnectorMode) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); note.style.zIndex = boardState.noteZIndexCounter++; const onMouseMove = ev => { handleDrag(note, ev); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); clearGuides(); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const resizer = note.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (note.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW = note.offsetWidth, startH = note.offsetHeight, startX = e.clientX, startY = e.clientY; const onMouseMove = ev => { note.style.width = `${startW + (ev.clientX - startX) / boardState.scale}px`; note.style.height = `${startH + (ev.clientY - startY) / boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const noteBody = note.querySelector('.note-body'); const view = note.querySelector('.note-view'); const content = note.querySelector('.note-content'); const deleteBtn = note.querySelector('.delete-btn'); const colorDots = note.querySelectorAll('.color-dot'); const lockBtn = note.querySelector('.lock-btn');
    noteBody.addEventListener('dblclick', (e) => { if (note.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); view.style.display = 'none'; content.style.display = 'block'; content.focus(); });
    content.addEventListener('blur', () => { if (note.classList.contains('locked')) return; view.innerHTML = parseMarkdown(content.value); view.style.display = 'block'; content.style.display = 'none'; commitChange(); });
    deleteBtn.addEventListener('click', (e) => { if (note.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === note) clearSelection(); recordHistory(); notes = notes.filter(n => n.id !== note.id); connectors = connectors.filter(c => c.startId !== note.id && c.endId !== note.id); drawAllConnectors(); note.remove(); saveState(); });
    colorDots.forEach(dot => { dot.addEventListener('click', e => { if (note.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); updateNoteColor(note, dot.dataset.color); saveState(); }); });
    lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = note.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); }); }
    function updateNoteColor(note, color) { note.dataset.color = color; note.querySelector('.note-header').style.backgroundColor = color; note.querySelector('.note-body').style.backgroundColor = color; }

    function createSection(data = {}) { const section = document.createElement('div'); section.classList.add('section'); section.id = data.id || `section-${Date.now()}`; if (!data.id) { section.style.left = `${((window.innerWidth/2)-200-boardState.panX)/boardState.scale}px`; section.style.top = `${((window.innerHeight/2)-200-boardState.panY)/boardState.scale}px`; } else { section.style.left = data.x; section.style.top = data.y; } section.style.width = data.width || '400px'; section.style.height = data.height || '400px'; section.style.zIndex = data.zIndex || boardState.sectionZIndexCounter++; section.style.backgroundColor = data.color || sectionColors[Math.floor(Math.random()*sectionColors.length)]; const title = data.title || '新しいセクション'; section.innerHTML = `<div class="section-header"><div class="section-title">${title}</div><div class="section-controls"><div class="color-picker">${sectionColors.map(c=>`<div class="color-dot" style="background-color: ${c};" data-color="${c}"></div>`).join('')}</div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div></div></div><div class="resizer"></div>`; board.insertBefore(section, svgLayer); sections.push(section); if (!data.id) commitChange(); if (data.isLocked) { section.classList.add('locked'); section.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    const startSectionDrag = (e) => { if (section.classList.contains('locked')) return; recordHistory(); document.body.classList.add('is-dragging'); section.style.zIndex = boardState.sectionZIndexCounter++; let attachedElements = []; const startLeft = parseFloat(section.style.left), startTop = parseFloat(section.style.top); [...notes, ...shapes, ...textBoxes, ...drawings].forEach(el => { const elLeft=parseFloat(el.style.left), elTop=parseFloat(el.style.top); if (elLeft > startLeft && elLeft + el.offsetWidth < startLeft + section.offsetWidth && elTop > startTop && elTop + el.offsetHeight < startTop + section.offsetHeight) { attachedElements.push({element: el, offsetX: elLeft - startLeft, offsetY: elTop - startTop}); } }); const onMouseMove = ev => { handleDrag(section, ev, attachedElements); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); clearGuides(); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); };
    const header = section.querySelector('.section-header'); header.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(section.id); return; } selectElement(section); startSectionDrag(e); }); section.addEventListener('mousedown', e => { if (e.target === section) { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(section.id); return; } selectElement(section); startSectionDrag(e); }});
    const resizer = section.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW=section.offsetWidth, startH=section.offsetHeight, startX=e.clientX, startY=e.clientY; const onMouseMove = ev => { section.style.width=`${startW+(ev.clientX-startX)/boardState.scale}px`; section.style.height=`${startH+(ev.clientY-startY)/boardState.scale}px`; drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const titleEl = section.querySelector('.section-title'); titleEl.addEventListener('dblclick', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); const i=document.createElement('input'); i.type='text'; i.value=titleEl.textContent; i.className='section-title-input'; titleEl.replaceWith(i); i.focus(); i.select(); i.addEventListener('blur',()=>{titleEl.textContent=i.value||"無題";i.replaceWith(titleEl);commitChange();}); i.addEventListener('keydown',(ev)=>{if(ev.key==='Enter')i.blur();}); });
    const deleteBtn = section.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === section) clearSelection(); recordHistory(); sections = sections.filter(s => s.id !== section.id); connectors = connectors.filter(c => c.startId !== section.id && c.endId !== section.id); drawAllConnectors(); section.remove(); saveState(); });
    const colorDots = section.querySelectorAll('.color-dot'); colorDots.forEach(dot => { dot.addEventListener('click', e => { if (section.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); section.style.backgroundColor = dot.dataset.color; saveState(); }); });
    const lockBtn = section.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = section.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); }); }

    function createTextBox(data = {}) { const textBox = document.createElement('div'); textBox.classList.add('text-box'); textBox.id = data.id || `text-${Date.now()}`; if (!data.id) { textBox.style.left = `${((window.innerWidth/2)-100-boardState.panX)/boardState.scale}px`; textBox.style.top = `${((window.innerHeight/2)-50-boardState.panY)/boardState.scale}px`; } else { textBox.style.left = data.x; textBox.style.top = data.y; } textBox.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; textBox.style.width = data.width || 'auto'; textBox.innerHTML = `<div class="text-content" contenteditable="false">${data.content || 'テキストを入力'}</div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div>`; board.insertBefore(textBox, svgLayer); textBoxes.push(textBox); if (!data.id) commitChange(); if (data.isLocked) { textBox.classList.add('locked'); textBox.querySelector('.lock-btn i').className = 'fas fa-lock'; textBox.querySelector('.text-content').contentEditable = 'false'; } else { textBox.querySelector('.text-content').contentEditable = 'true'; }
    const content = textBox.querySelector('.text-content'); textBox.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(textBox.id); return; } selectElement(textBox); if (textBox.classList.contains('locked')) return; if (e.target !== content) { document.body.classList.add('is-dragging'); recordHistory(); textBox.style.zIndex = boardState.noteZIndexCounter++; const onMouseMove = ev => { handleDrag(textBox, ev); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); clearGuides(); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); } });
    content.addEventListener('input', () => { if (textBox.classList.contains('locked')) return; textBox.style.width = 'auto'; commitChange(); }); content.addEventListener('mousedown', e => e.stopPropagation());
    const deleteBtn = textBox.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (textBox.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === textBox) clearSelection(); recordHistory(); textBoxes = textBoxes.filter(t => t.id !== textBox.id); connectors = connectors.filter(c => c.startId !== textBox.id && c.endId !== textBox.id); drawAllConnectors(); textBox.remove(); saveState(); });
    const lockBtn = textBox.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = textBox.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; content.contentEditable = !isLocked; if(isLocked) clearSelection(); saveState(); }); }

    function createShape(data = {}) { const shape = document.createElement('div'); shape.classList.add('shape', data.type); shape.dataset.shapeType = data.type; shape.id = data.id || `shape-${Date.now()}`; if (!data.id) { shape.style.left = `${((window.innerWidth/2)-75-boardState.panX)/boardState.scale}px`; shape.style.top = `${((window.innerHeight/2)-75-boardState.panY)/boardState.scale}px`; } else { shape.style.left = data.x; shape.style.top = data.y; } shape.style.width = data.width || '150px'; shape.style.height = data.height || '150px'; shape.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; shape.innerHTML = `<div class="shape-visual"></div><div class="shape-label" contenteditable="false">${data.label || ''}</div><div class="resizer"></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="color-picker">${shapeColors.map(c => `<div class="color-dot" style="background-color: ${c};" data-color="${c}"></div>`).join('')}</div>`; board.insertBefore(shape, svgLayer); shapes.push(shape); const visual = shape.querySelector('.shape-visual'); visual.style.backgroundColor = data.color || shapeColors[0]; if (!data.id) commitChange(); if (data.isLocked) { shape.classList.add('locked'); shape.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    shape.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(shape.id); return; } selectElement(shape); if (shape.classList.contains('locked')) return; if (e.target.classList.contains('shape-visual') || e.target.classList.contains('shape')) { document.body.classList.add('is-dragging'); recordHistory(); shape.style.zIndex = boardState.noteZIndexCounter++; const onMouseMove = ev => { handleDrag(shape, ev); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); clearGuides(); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); } });
    const resizer = shape.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW=shape.offsetWidth, startH=shape.offsetHeight, startX=e.clientX, startY=e.clientY; const aspectRatio = startW / startH; const onMouseMove = ev => { if (ev.shiftKey) { const deltaX = ev.clientX - startX; const newWidth = startW + deltaX / boardState.scale; shape.style.width=`${newWidth}px`; shape.style.height=`${newWidth / aspectRatio}px`; } else { shape.style.width=`${startW+(ev.clientX-startX)/boardState.scale}px`; shape.style.height=`${startH+(ev.clientY-startY)/boardState.scale}px`; } drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const label = shape.querySelector('.shape-label'); label.addEventListener('dblclick', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); label.contentEditable = 'true'; label.focus(); }); label.addEventListener('blur', () => { label.contentEditable = 'false'; commitChange(); }); label.addEventListener('mousedown', e => e.stopPropagation());
    const deleteBtn = shape.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === shape) clearSelection(); recordHistory(); shapes = shapes.filter(s => s.id !== shape.id); connectors = connectors.filter(c => c.startId !== shape.id && c.endId !== shape.id); drawAllConnectors(); shape.remove(); saveState(); });
    const colorDots = shape.querySelectorAll('.color-dot'); colorDots.forEach(dot => { dot.addEventListener('click', e => { if (shape.classList.contains('locked')) return; e.stopPropagation(); recordHistory(); shape.querySelector('.shape-visual').style.backgroundColor = dot.dataset.color; saveState(); }); });
    const lockBtn = shape.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = shape.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); }); }

    function createDrawing(data = {}) { const drawing = document.createElement('div'); drawing.classList.add('drawing'); drawing.id = data.id || `drawing-${Date.now()}`; drawing.style.left = data.x; drawing.style.top = data.y; drawing.style.width = data.width; drawing.style.height = data.height; drawing.style.zIndex = data.zIndex || boardState.noteZIndexCounter++; drawing.innerHTML = `<canvas class="drawing-canvas"></canvas><div class="resizer"></div><div class="delete-btn" title="削除"><i class="fas fa-times"></i></div><div class="lock-btn" title="ロック"><i class="fas fa-unlock"></i></div><div class="drawing-controls"><input type="color" value="${data.color || '#000000'}" title="線の色"><input type="range" min="1" max="20" value="${data.strokeWidth || 2}" title="線の太さ"></div>`; board.insertBefore(drawing, svgLayer); drawings.push(drawing); const canvas = drawing.querySelector('.drawing-canvas'); const ctx = canvas.getContext('2d'); drawing.paths = data.paths || []; drawing.color = data.color || '#000000'; drawing.strokeWidth = data.strokeWidth || 2;
    function redraw() { const rect = drawing.getBoundingClientRect(); canvas.width = drawing.offsetWidth; canvas.height = drawing.offsetHeight; ctx.strokeStyle = drawing.color; ctx.lineWidth = drawing.strokeWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; drawing.paths.forEach(path => { ctx.beginPath(); if (path.length > 0) { ctx.moveTo(path[0].x, path[0].y); path.slice(1).forEach(point => ctx.lineTo(point.x, point.y)); ctx.stroke(); } }); }
    redraw(); if (data.isLocked) { drawing.classList.add('locked'); drawing.querySelector('.lock-btn i').className = 'fas fa-lock'; }
    drawing.addEventListener('mousedown', e => { e.stopPropagation(); if (isConnectorMode) { handleConnectorClick(drawing.id); return; } selectElement(drawing); if (drawing.classList.contains('locked')) return; recordHistory(); drawing.style.zIndex = boardState.noteZIndexCounter++; document.body.classList.add('is-dragging'); const onMouseMove = ev => { handleDrag(drawing, ev); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); clearGuides(); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const resizer = drawing.querySelector('.resizer'); resizer.addEventListener('mousedown', e => { if (drawing.classList.contains('locked')) return; e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const startW = drawing.offsetWidth, startH = drawing.offsetHeight, startX = e.clientX, startY = e.clientY; const onMouseMove = ev => { const newWidth = startW + (ev.clientX - startX) / boardState.scale; const newHeight = startH + (ev.clientY - startY) / boardState.scale; drawing.style.width = `${newWidth}px`; drawing.style.height = `${newHeight}px`; redraw(); drawAllConnectors(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); });
    const deleteBtn = drawing.querySelector('.delete-btn'); deleteBtn.addEventListener('click', e => { if (drawing.classList.contains('locked')) return; e.stopPropagation(); if (selectedElement === drawing) clearSelection(); recordHistory(); drawings = drawings.filter(d => d.id !== drawing.id); connectors = connectors.filter(c => c.startId !== drawing.id && c.endId !== drawing.id); drawAllConnectors(); drawing.remove(); saveState(); });
    const lockBtn = drawing.querySelector('.lock-btn'); lockBtn.addEventListener('click', e => { e.stopPropagation(); recordHistory(); const isLocked = drawing.classList.toggle('locked'); lockBtn.querySelector('i').className = isLocked ? 'fas fa-lock' : 'fas fa-unlock'; if(isLocked) clearSelection(); saveState(); });
    const colorInput = drawing.querySelector('input[type="color"]'); colorInput.addEventListener('input', e => { if (drawing.classList.contains('locked')) return; recordHistory(); drawing.color = e.target.value; redraw(); saveState(); });
    const widthInput = drawing.querySelector('input[type="range"]'); widthInput.addEventListener('input', e => { if (drawing.classList.contains('locked')) return; recordHistory(); drawing.strokeWidth = e.target.value; redraw(); saveState(); }); }
    
    function handleDrag(element, event, attachedElements = []) { const currentLeft = parseFloat(element.style.left); const currentTop = parseFloat(element.style.top); const snapped = snapAndGuide(element, currentLeft + event.movementX/boardState.scale, currentTop + event.movementY/boardState.scale); const dx = snapped.x - currentLeft; const dy = snapped.y - currentTop; element.style.left = `${snapped.x}px`; element.style.top = `${snapped.y}px`; attachedElements.forEach(item => { item.element.style.left = `${parseFloat(item.element.style.left) + dx}px`; item.element.style.top = `${parseFloat(item.element.style.top) + dy}px`; }); drawAllConnectors(); }
    const SNAP_THRESHOLD = 5;
    function snapAndGuide(draggedEl, newX, newY) { clearGuides(); const draggedRect = { left: newX, top: newY, width: draggedEl.offsetWidth, height: draggedEl.offsetHeight }; const draggedPoints = { v: [draggedRect.left, draggedRect.left + draggedRect.width / 2, draggedRect.left + draggedRect.width], h: [draggedRect.top, draggedRect.top + draggedRect.height / 2, draggedRect.top + draggedRect.height] }; let finalX = newX, finalY = newY; let snappedX = false, snappedY = false; const allElements = [...notes, ...sections, ...textBoxes, ...shapes, ...drawings];
    allElements.forEach(targetEl => { if (targetEl === draggedEl) return; const targetRect = { left: parseFloat(targetEl.style.left), top: parseFloat(targetEl.style.top), width: targetEl.offsetWidth, height: targetEl.offsetHeight }; const targetPoints = { v: [targetRect.left, targetRect.left + targetRect.width / 2, targetRect.left + targetRect.width], h: [targetRect.top, targetRect.top + targetRect.height / 2, targetRect.top + targetRect.height] }; for (let i = 0; i < 3; i++) { if (!snappedX) { for (let j = 0; j < 3; j++) { const diff = draggedPoints.v[i] - targetPoints.v[j]; if (Math.abs(diff) < SNAP_THRESHOLD / boardState.scale) { finalX -= diff; createGuide(targetPoints.v[j], 'vertical'); snappedX = true; break; } } } if (!snappedY) { for (let j = 0; j < 3; j++) { const diff = draggedPoints.h[i] - targetPoints.h[j]; if (Math.abs(diff) < SNAP_THRESHOLD / boardState.scale) { finalY -= diff; createGuide(targetPoints.h[j], 'horizontal'); snappedY = true; break; } } } } });
    return { x: finalX, y: finalY }; }
    function createGuide(pos, orientation) { const guide = document.createElement('div'); guide.className = `guide-line ${orientation}`; if (orientation === 'vertical') guide.style.left = `${pos}px`; else guide.style.top = `${pos}px`; document.getElementById('guide-container').appendChild(guide); }
    function clearGuides() { const container = document.getElementById('guide-container'); if(container) container.innerHTML = ''; }
    
    function updateMinimap() { minimap.innerHTML = ''; const minimapScale = minimap.offsetWidth / board.offsetWidth; [...notes, ...sections, ...textBoxes, ...shapes, ...drawings].forEach(el => { const elRect = { left: parseFloat(el.style.left) * minimapScale, top: parseFloat(el.style.top) * minimapScale, width: el.offsetWidth * minimapScale, height: el.offsetHeight * minimapScale }; const mapEl = document.createElement('div'); mapEl.className = 'minimap-element'; mapEl.style.cssText = `left:${elRect.left}px; top:${elRect.top}px; width:${elRect.width}px; height:${elRect.height}px;`; minimap.appendChild(mapEl); }); const viewport = document.createElement('div'); viewport.id = 'minimap-viewport'; minimap.appendChild(viewport); const viewRect = { width: window.innerWidth / boardState.scale * minimapScale, height: window.innerHeight / boardState.scale * minimapScale, left: -boardState.panX * minimapScale, top: -boardState.panY * minimapScale }; viewport.style.cssText = `width:${viewRect.width}px; height:${viewRect.height}px; left:${viewRect.left}px; top:${viewRect.top}px;`; viewport.addEventListener('mousedown', e => { e.stopPropagation(); document.body.classList.add('is-dragging'); recordHistory(); const onMouseMove = ev => { boardState.panX -= ev.movementX / minimapScale; boardState.panY -= ev.movementY / minimapScale; applyTransform(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); }); }
    
    window.addEventListener('keydown', e => { if (mainApp.classList.contains('hidden')) return; if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } if (e.ctrlKey && e.key.toLowerCase() === 'y' || (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z')) { e.preventDefault(); redo(); } if (!selectedElement) return; if (document.activeElement.isContentEditable || /TEXTAREA|INPUT/.test(document.activeElement.tagName)) return; if (e.key === 'Delete' || e.key === 'Backspace') { e.preventDefault(); if (selectedElement.type === 'connector') { recordHistory(); connectors = connectors.filter(c => c.id !== selectedElement.id); drawAllConnectors(); saveState(); clearSelection(); return; } if (selectedElement.classList.contains('locked')) return; selectedElement.querySelector('.delete-btn')?.click(); } if (e.ctrlKey && e.key.toLowerCase() === 'd') { e.preventDefault(); if (selectedElement.classList.contains('locked') || selectedElement.type === 'connector') return; let originalData, createFn; const fileData = JSON.parse(localStorage.getItem(currentFileId)); if (selectedElement.classList.contains('note')) { originalData = fileData.notes.find(n => n.id === selectedElement.id); createFn = createNote; } else if (selectedElement.classList.contains('section')) { originalData = fileData.sections.find(s => s.id === selectedElement.id); createFn = createSection; } else if (selectedElement.classList.contains('text-box')) { originalData = fileData.textBoxes.find(t => t.id === selectedElement.id); createFn = createTextBox; } else if (selectedElement.classList.contains('shape')) { originalData = fileData.shapes.find(s => s.id === selectedElement.id); createFn = createShape; } else if (selectedElement.classList.contains('drawing')) { originalData = fileData.drawings.find(d => d.id === selectedElement.id); createFn = createDrawing; } if (createFn) { recordHistory(); const dataToClone = { ...originalData }; delete dataToClone.id; delete dataToClone.zIndex; dataToClone.x = `${parseFloat(dataToClone.x) + 20 / boardState.scale}px`; dataToClone.y = `${parseFloat(dataToClone.y) + 20 / boardState.scale}px`; createFn(dataToClone); } } });
    window.addEventListener('wheel', e => { e.preventDefault(); recordHistory(); if (e.shiftKey) { boardState.panX -= e.deltaY; } else { const z = 1.1, o = boardState.scale; let n=e.deltaY<0?o*z:o/z; n=Math.max(0.2,Math.min(n,3.0)); boardState.scale=n; boardState.panX=e.clientX-((e.clientX-boardState.panX)/o*n); boardState.panY=e.clientY-((e.clientY-boardState.panY)/o*n); } applyTransform(); saveState(); }, { passive: false });
    board.addEventListener('mousedown', e => { if (e.target !== board) return; clearSelection(); toggleConnectorMode(true); toggleDrawingMode(true); if(isDrawingMode) { document.body.classList.add('is-dragging'); recordHistory(); const startX = (e.clientX - boardState.panX) / boardState.scale; const startY = (e.clientY - boardState.panY) / boardState.scale; currentDrawingPath = [{x: startX, y: startY}]; currentDrawingElement = document.createElementNS('http://www.w3.org/2000/svg', 'path'); currentDrawingElement.setAttribute('stroke', '#000'); currentDrawingElement.setAttribute('stroke-width', '2'); currentDrawingElement.setAttribute('fill', 'none'); svgLayer.appendChild(currentDrawingElement); const onMouseMove = ev => { currentDrawingPath.push({x: (ev.clientX - boardState.panX) / boardState.scale, y: (ev.clientY - boardState.panY) / boardState.scale}); let pathData = `M ${currentDrawingPath[0].x} ${currentDrawingPath[0].y} `; currentDrawingPath.slice(1).forEach(p => {pathData += `L ${p.x} ${p.y} `}); currentDrawingElement.setAttribute('d', pathData); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); svgLayer.removeChild(currentDrawingElement); finalizeDrawing(); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); } else { document.body.classList.add('is-dragging'); board.classList.add('grabbing'); recordHistory(); const onMouseMove = ev => { boardState.panX += ev.movementX; boardState.panY += ev.movementY; applyTransform(); }; const onMouseUp = () => { document.body.classList.remove('is-dragging'); board.classList.remove('grabbing'); document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); saveState(); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); } });
    function finalizeDrawing() { if (!currentDrawingPath || currentDrawingPath.length < 2) return; const minX = Math.min(...currentDrawingPath.map(p => p.x)); const minY = Math.min(...currentDrawingPath.map(p => p.y)); const maxX = Math.max(...currentDrawingPath.map(p => p.x)); const maxY = Math.max(...currentDrawingPath.map(p => p.y)); const width = maxX - minX; const height = maxY - minY; const normalizedPaths = [currentDrawingPath.map(p => ({x: p.x - minX, y: p.y - minY}))]; createDrawing({ x: `${minX}px`, y: `${minY}px`, width: `${width}px`, height: `${height}px`, paths: normalizedPaths }); currentDrawingPath = null; toggleDrawingMode(true); }
    zoomResetBtn.addEventListener('click', () => {recordHistory();
    const oldScale = boardState.scale;
    const newScale = 1.0;

    // 現在の画面中心を基準点とする
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // 視点を維持したままスケールをリセットするための新しいpan値を計算
    boardState.panX = centerX - ((centerX - boardState.panX) / oldScale * newScale);
    boardState.panY = centerY - ((centerY - boardState.panY) / oldScale * newScale);
    boardState.scale = newScale;
    
    applyTransform(); 
    saveState(); 
    }); 
    addNoteBtn.addEventListener('click', () => { toggleConnectorMode(true); toggleDrawingMode(true); createNote(); }); addSectionBtn.addEventListener('click', () => { toggleConnectorMode(true); toggleDrawingMode(true); createSection(); }); addTextBtn.addEventListener('click', () => { toggleConnectorMode(true); toggleDrawingMode(true); createTextBox(); }); addShapeSquareBtn.addEventListener('click', () => { toggleConnectorMode(true); toggleDrawingMode(true); createShape({type: 'square'}); }); addShapeCircleBtn.addEventListener('click', () => { toggleConnectorMode(true); toggleDrawingMode(true); createShape({type: 'circle'}); }); addShapeDiamondBtn.addEventListener('click', () => { toggleConnectorMode(true); toggleDrawingMode(true); createShape({type: 'diamond'}); }); addConnectorBtn.addEventListener('click', () => toggleConnectorMode()); penToolBtn.addEventListener('click', () => toggleDrawingMode());
    backToFilesBtn.addEventListener('click', showFileManager); createNewFileBtn.addEventListener('click', createNewFile);
    darkModeBtn.addEventListener('click', () => { document.body.classList.toggle('dark-mode'); localStorage.setItem('plottia-dark-mode', document.body.classList.contains('dark-mode') ? '1' : '0' ); });
    exportBtn.addEventListener('click', () => { saveState(); const d = localStorage.getItem(currentFileId); if (!d) { alert('エクスポートするデータがありません。'); return; } const b = new Blob([d],{type:'application/json'}); const a = document.createElement('a'); a.download=`${getFileMetadata().find(f=>f.id===currentFileId)?.name || 'board'}.json`; a.href=URL.createObjectURL(b); a.click(); URL.revokeObjectURL(a.href); });
    importBtn.addEventListener('click', () => importFileInput.click()); importFileInput.addEventListener('change', e => { const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=ev=>{try{ JSON.parse(ev.target.result); if(confirm('現在のボードをインポートした内容で上書きします。よろしいですか？')){ recordHistory(); localStorage.setItem(currentFileId, ev.target.result); loadState();}}catch(err){alert('無効なファイルです。')}}; r.readAsText(f); e.target.value='';});
    cleanupBtn.addEventListener('click', () => { if (confirm('すべてのファイルとデータを消去して完全にリセットします。この操作は元に戻せません。よろしいですか？')) { localStorage.clear(); location.reload(); } });
    undoBtn.addEventListener('click', undo); redoBtn.addEventListener('click', redo);

    if (localStorage.getItem('plottia-dark-mode') === '1') { document.body.classList.add('dark-mode'); }
    showFileManager();
});